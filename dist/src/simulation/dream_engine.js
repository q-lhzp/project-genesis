// ---------------------------------------------------------------------------
// Dream Engine - Sleep & Dream Cycle for Neural Memory Consolidation
// Phase 27: Dream-Mode (Neural Memory Consolidation)
// ---------------------------------------------------------------------------
import { join } from "node:path";
import { existsSync, mkdirSync, readdirSync, readFileSync, writeFileSync, appendFileSync } from "node:fs";
const DEFAULT_CONFIG = {
    sleepStartHour: 23,
    sleepEndHour: 5,
    energyThreshold: 20,
    dreamDurationMs: 5000
};
let currentDreamState = {
    isDreaming: false,
    sleepStartTime: null,
    dreamCount: 0,
    lastWakeTime: null,
    lastDreamSummary: null
};
/**
 * Check if current time is in sleep window
 */
function isSleepTime(config = DEFAULT_CONFIG) {
    const now = new Date();
    const hour = now.getHours();
    // Sleep window spans midnight (e.g., 23:00 - 05:00)
    if (config.sleepStartHour > config.sleepEndHour) {
        // Night mode (23:00 - 05:00)
        return hour >= config.sleepStartHour || hour < config.sleepEndHour;
    }
    return hour >= config.sleepStartHour && hour < config.sleepEndHour;
}
/**
 * Get today's experiences from jsonl files
 */
async function getTodayExperiences(workspacePath) {
    const experiencesDir = join(workspacePath, "memory", "experiences");
    const experiences = [];
    if (!existsSync(experiencesDir)) {
        return experiences;
    }
    const today = new Date().toISOString().slice(0, 10); // YYYY-MM-DD
    try {
        const files = readdirSync(experiencesDir);
        for (const file of files) {
            if (file.startsWith(today) && file.endsWith(".jsonl")) {
                const filePath = join(experiencesDir, file);
                const lines = readFileSync(filePath, "utf-8").split("\n");
                for (const line of lines) {
                    if (line.trim()) {
                        try {
                            const entry = JSON.parse(line);
                            experiences.push(entry.message || entry.text || entry.content || "");
                        }
                        catch {
                            // Skip invalid JSON
                        }
                    }
                }
            }
        }
    }
    catch (error) {
        console.log(`[dream_engine] Error reading experiences: ${error}`);
    }
    return experiences;
}
/**
 * Generate a dream summary from experiences
 */
function generateDreamSummary(experiences) {
    if (experiences.length === 0) {
        return "No significant experiences to process tonight. The mind rests in peaceful stillness.";
    }
    // Take last 10 experiences
    const recent = experiences.slice(-10);
    // Simple summarization - in production, this could use an LLM
    const summary = `Dreaming of today's journey... Processed ${experiences.length} experiences. ` +
        `Key moments: ${recent.slice(-3).join(" | ")}`;
    return summary;
}
/**
 * Extract key insights from experiences
 */
function extractInsights(experiences) {
    const insights = [];
    // Simple keyword-based insight extraction
    // In production, this would use NLP/LLM
    const keywords = ["learned", "realized", "understood", "discovered", "insight", "growth", "change"];
    for (const exp of experiences) {
        const lower = exp.toLowerCase();
        for (const keyword of keywords) {
            if (lower.includes(keyword)) {
                // Extract sentence containing keyword
                const sentences = exp.split(/[.!?]+/);
                for (const sentence of sentences) {
                    if (sentence.toLowerCase().includes(keyword) && sentence.trim().length > 10) {
                        insights.push(sentence.trim());
                    }
                }
            }
        }
    }
    // Return top 3 insights
    return insights.slice(0, 3);
}
/**
 * Write dream log to dreams directory
 */
async function logDream(workspacePath, summary, insights) {
    const dreamsDir = join(workspacePath, "memory", "reality", "dreams");
    mkdirSync(dreamsDir, { recursive: true });
    const now = new Date();
    const dateStr = now.toISOString().slice(0, 10);
    const filename = `dream_${dateStr}.md`;
    const filepath = join(dreamsDir, filename);
    const content = `# Dream Log - ${dateStr}

## Time
${now.toISOString()}

## Dream Summary
${summary}

## Key Insights Extracted
${insights.map((i, idx) => `${idx + 1}. ${i}`).join("\n")}

---

*Generated by Project Genesis Dream Engine*
`;
    writeFileSync(filepath, content, "utf-8");
    console.log(`[dream_engine] Dream logged to: ${filepath}`);
}
/**
 * Write growth entry
 */
async function injectGrowth(workspacePath, insights) {
    if (insights.length === 0)
        return;
    const growthPath = join(workspacePath, "memory", "reality", "GROWTH.md");
    const now = new Date();
    const entry = `\n\n## ${now.toISOString().slice(0, 10)} - Dream Insight\n${insights.map(i => `- ${i}`).join("\n")}`;
    try {
        if (existsSync(growthPath)) {
            appendFileSync(growthPath, entry, "utf-8");
        }
        else {
            writeFileSync(growthPath, `# Growth Log\n${entry}`, "utf-8");
        }
        console.log(`[dream_engine] Growth insights injected`);
    }
    catch (error) {
        console.log(`[dream_engine] Failed to write growth: ${error}`);
    }
}
/**
 * Process dream cycle - consolidate memories and recover vitals
 */
async function processDreamCycle(workspacePath, physique) {
    console.log("[dream_engine] Processing dream cycle...");
    // 1. Get today's experiences
    const experiences = await getTodayExperiences(workspacePath);
    // 2. Generate dream summary
    const summary = generateDreamSummary(experiences);
    // 3. Extract insights
    const insights = extractInsights(experiences);
    // 4. Log dream
    await logDream(workspacePath, summary, insights);
    // 5. Inject growth
    await injectGrowth(workspacePath, insights);
    // 6. Recover vitals (simulating sleep recovery)
    physique.needs.energy = 100;
    physique.needs.stress = 0;
    physique.last_tick = new Date().toISOString();
    return { summary, insights };
}
/**
 * Check if Q should enter dream mode
 */
export function shouldEnterDreamMode(physique, config = DEFAULT_CONFIG) {
    // Already dreaming
    if (currentDreamState.isDreaming)
        return true;
    // Check time and energy
    const inSleepWindow = isSleepTime(config);
    const lowEnergy = (physique.needs?.energy ?? 100) < config.energyThreshold;
    return inSleepWindow && lowEnergy;
}
/**
 * Check if Q should wake up
 */
export function shouldWakeUp(physique, config = DEFAULT_CONFIG) {
    // Currently dreaming
    if (!currentDreamState.isDreaming)
        return false;
    // Check if sleep window has ended or energy is fully restored
    const outOfSleepWindow = !isSleepTime(config);
    const fullyRestored = (physique.needs?.energy ?? 0) >= 100;
    return outOfSleepWindow || fullyRestored;
}
/**
 * Main dream cycle handler - call this from tick
 */
export async function processDreamState(workspacePath, physique) {
    const config = DEFAULT_CONFIG;
    // Check if should start dreaming
    if (shouldEnterDreamMode(physique, config)) {
        if (!currentDreamState.isDreaming) {
            console.log("[dream_engine] Entering Dream Mode...");
            currentDreamState.isDreaming = true;
            currentDreamState.sleepStartTime = new Date().toISOString();
            currentDreamState.dreamCount++;
        }
        // Process dream (memory consolidation)
        const result = await processDreamCycle(workspacePath, physique);
        currentDreamState.lastDreamSummary = result.summary;
        return {
            isDreaming: true,
            dreamSummary: result.summary,
            vitalsRecovered: true
        };
    }
    // Check if should wake up
    if (shouldWakeUp(physique, config)) {
        if (currentDreamState.isDreaming) {
            console.log("[dream_engine] Waking up from Dream Mode...");
            currentDreamState.isDreaming = false;
            currentDreamState.lastWakeTime = new Date().toISOString();
        }
        return {
            isDreaming: false,
            dreamSummary: currentDreamState.lastDreamSummary,
            vitalsRecovered: true
        };
    }
    return {
        isDreaming: currentDreamState.isDreaming,
        dreamSummary: null,
        vitalsRecovered: false
    };
}
/**
 * Get current dream state (for UI display)
 */
export function getDreamState() {
    return { ...currentDreamState };
}
/**
 * Check if sleep is currently locked (during dream mode)
 */
export function isSleepLocked() {
    return currentDreamState.isDreaming;
}
/**
 * Get morning report (for context injection after waking)
 */
export function getMorningReport() {
    if (!currentDreamState.lastWakeTime || !currentDreamState.lastDreamSummary) {
        return null;
    }
    // Only return if wake was recent (within last hour)
    const wakeTime = new Date(currentDreamState.lastWakeTime);
    const now = new Date();
    const hoursSinceWake = (now.getTime() - wakeTime.getTime()) / (1000 * 60 * 60);
    if (hoursSinceWake > 1) {
        return null;
    }
    return `## Morning Reflection\nLast night's dream consolidated today's experiences.\n${currentDreamState.lastDreamSummary}`;
}
//# sourceMappingURL=dream_engine.js.map